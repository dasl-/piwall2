#!/usr/bin/env python3

import argparse
import subprocess
import os
import socket
import sys
import shlex

# This is necessary for the imports below to work
root_dir = os.path.abspath(os.path.dirname(__file__) + '/..')
sys.path.append(root_dir)
from piwall2.configloader import ConfigLoader
from piwall2.cmdrunner import CmdRunner
from piwall2.directoryutils import DirectoryUtils

def main():
    args = parse_args()

    cmd_runner = CmdRunner()

    install_bootstrap_dependencies(cmd_runner)
    if args.setup_ssh:
        if args.ssh_password is None:
            raise Exception("When setting up SSH, '--receiver-ssh-password' must be specified.")
        generate_ssh_key(CmdRunner.SSH_KEY_PATH)
        authorize_ssh_key(CmdRunner.SSH_KEY_PATH, args.ssh_password, cmd_runner)
    copy_config_to_receivers(cmd_runner)
    if args.install_dependencies:
        install_dependencies(cmd_runner)
    if args.install_app:
        install_app(cmd_runner, args.enable_receivers_composite_video_out, args.dont_disable_wifi)
    print("Success!")

def parse_args():
    parser = argparse.ArgumentParser(description=
f"""Applies the receivers config located in: {ConfigLoader.RECEIVERS_CONFIG_PATH}.
This script should be run on the broadcaster. This script does several things:
1) Sets up passwordless SSH from the broadcaster to each receiver
2) Installs piwall2 dependencies on the broadcaster and receivers
3) Installs the application on the broadcaster and receivers
""",
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)
    parser.add_argument('--dont-setup-ssh', dest='setup_ssh', action='store_false', default=True,
        help="Skip setting up SSH.")
    parser.add_argument('--ssh-password', dest='ssh_password', action='store', default=None,
        help="SSH password for logging into the broadcaster and receiver raspberry pis. If you " +
        "haven't changed this, it will be 'raspberry'. Required if setting up SSH.")
    parser.add_argument('--dont-install-dependencies', dest='install_dependencies', action='store_false',
        default=True, help="Skip installing dependencies.")
    parser.add_argument('--dont-install-app', dest='install_app', action='store_false',
        default=True, help="Skip installing app.")
    parser.add_argument('--enable-receivers-composite-video-out',
        dest='enable_receivers_composite_video_out', action='store_true', default=False,
        help="Enable composite video output on the receivers. This will detrimentally affect their " +
        "performance to a small degree.")
    parser.add_argument('--dont-disable-wifi', dest='dont_disable_wifi', action='store_true', default=False,
        help="Don't disable wifi. Only specify this option if you know what you're doing.")
    args = parser.parse_args()
    return args

# generate the SSH key that the broadcaster will use for passwordless SSH
def generate_ssh_key(file):
    print(f"Generating ssh key: {file} ...")

    dirname = os.path.dirname(file)
    output = (subprocess
        .check_output(
            f"mkdir -p {shlex.quote(dirname)}",
            shell = True,
            executable = '/usr/bin/bash',
            stderr = subprocess.STDOUT
        )
    )

    # https://stackoverflow.com/a/43235320/627663
    output = (subprocess
        .check_output(
            f"ssh-keygen -q -t ed25519 -N '' -f {shlex.quote(file)} <<<y >/dev/null 2>&1",
            shell = True,
            executable = '/usr/bin/bash',
            stderr = subprocess.STDOUT
        )
    )

def authorize_ssh_key(file, password, cmd_runner):
    print("Authorizing ssh key on broadcaster and receivers...")
    ssh_opts = ' '.join(CmdRunner.STANDARD_SSH_OPTS)
    authorize_ssh_key_cmd = (
        f"sshpass -p {shlex.quote(password)} " +
        f"ssh-copy-id {ssh_opts} " +
        f"-i {shlex.quote(file)} " + "pi@{}"
    )
    cmd_runner.run_parallel(authorize_ssh_key_cmd)

def copy_config_to_receivers(cmd_runner):
    cmd = DirectoryUtils().root_dir + "/utils/copy_config_to_receivers"
    exit_code = cmd_runner.run_cmd_with_realtime_output(cmd, raise_on_failure = False)
    if exit_code == 99:
        # This indicates the config file could not be found. That's ok, let people be able to define it later
        # and finish the setup.
        pass
    elif exit_code != 0:
        raise Exception(f"Unable to run {cmd}!")

def install_dependencies(cmd_runner):
    broadcaster_and_receivers = cmd_runner.get_broadcaster_and_receivers_hostname_list()
    broadcaster_hostname = socket.gethostname()
    print(f"Installing dependencies on: {broadcaster_and_receivers}...")
    install_deps_cmd = (f"{DirectoryUtils().root_dir}/install/install_dependencies.sh -t " +
        f"$(if [[ $(hostname) == \"{broadcaster_hostname}\" ]]; then echo broadcaster ; else echo receiver ; fi)")
    cmd_runner.run_dsh(install_deps_cmd)
    restart_hosts_if_required(cmd_runner)

def install_app(cmd_runner, enable_receivers_composite_video_out, dont_disable_wifi):
    broadcaster_and_receivers = cmd_runner.get_broadcaster_and_receivers_hostname_list()
    broadcaster_hostname = socket.gethostname()
    print(f"Installing app on: {broadcaster_and_receivers}...")
    install_app_cmd = (f"{DirectoryUtils().root_dir}/install/install.sh -t " +
        f"$(if [[ $(hostname) == \"{broadcaster_hostname}\" ]]; then echo broadcaster ; else echo receiver ; fi)")
    if enable_receivers_composite_video_out:
        install_app_cmd += " -c"
    if dont_disable_wifi:
        install_app_cmd += " -w"
    cmd_runner.run_dsh(install_app_cmd)
    restart_hosts_if_required(cmd_runner)

# install dependencies necessary to run this script
def install_bootstrap_dependencies(cmd_runner):
    print("Determining which bootstrap dependencies to install...")
    deps = ['parallel', 'dsh', 'sshpass']
    deps_to_install = []
    for dep in deps:
        if not is_program_installed(dep):
            deps_to_install.append(dep)
    if deps_to_install:
        deps_to_install = ' '.join(deps_to_install)
        print(f"Installing bootstrap dependencies: {deps_to_install}...")
        cmd_runner.run_cmd_with_realtime_output(f"sudo apt -y install {deps_to_install}")
    else:
        print("No bootstrap dependencies needed installing.")

def is_program_installed(program):
    try:
        output = (subprocess
            .check_output(
                f"which {shlex.quote(program)}",
                shell = True,
                executable = '/usr/bin/bash',
                stderr = subprocess.STDOUT
            )
        )
    except subprocess.CalledProcessError as e:
        if e.returncode == 1:
            return False
        else:
            raise e
    except Exception as e:
        raise e
    return True


"""
The install scripts will create a special file in /tmp if a restart is required after they run.
After the install scripts run, we let this coordinator script determine if a restart is required to avoid
restarting the broadcaster while it is still in the middle of running a dsh command

The raspberry pi appears to delete the whole /tmp directory upon restart, so we don't need to do anything
special to delete the file once we've restarted.
"""
def restart_hosts_if_required(cmd_runner):
    # restart receivers, if necessary
    cmd = ('{ [ -f /tmp/piwall2_install_restart_required ] && echo "Restarting..." && ' +
        'sudo shutdown -r now ; } || echo "Restart not needed."')
    cmd_runner.run_dsh(cmd, include_broadcaster = False)

    # restart broadcaster, if necessary
    cmd_runner.run_cmd_with_realtime_output(cmd.strip("'"))


main()
